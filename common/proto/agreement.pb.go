// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: agreement.proto

package proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FrameType int32

const (
	FrameType_Ping   FrameType = 0
	FrameType_Normal FrameType = 1
)

var FrameType_name = map[int32]string{
	0: "Ping",
	1: "Normal",
}

var FrameType_value = map[string]int32{
	"Ping":   0,
	"Normal": 1,
}

func (x FrameType) String() string {
	return proto.EnumName(FrameType_name, int32(x))
}

func (FrameType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{0}
}

type PkgType int32

const (
	PkgType_Hello    PkgType = 0
	PkgType_Exchange PkgType = 1
	PkgType_Query    PkgType = 2
	PkgType_Answer   PkgType = 3
)

var PkgType_name = map[int32]string{
	0: "Hello",
	1: "Exchange",
	2: "Query",
	3: "Answer",
}

var PkgType_value = map[string]int32{
	"Hello":    0,
	"Exchange": 1,
	"Query":    2,
	"Answer":   3,
}

func (x PkgType) String() string {
	return proto.EnumName(PkgType_name, int32(x))
}

func (PkgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{1}
}

type KeyType int32

const (
	KeyType_Ecc256 KeyType = 0
	KeyType_Ecc384 KeyType = 1
	KeyType_Ecc512 KeyType = 2
)

var KeyType_name = map[int32]string{
	0: "Ecc256",
	1: "Ecc384",
	2: "Ecc512",
}

var KeyType_value = map[string]int32{
	"Ecc256": 0,
	"Ecc384": 1,
	"Ecc512": 2,
}

func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}

func (KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{2}
}

type NodeType int32

const (
	NodeType_Common   NodeType = 0
	NodeType_Pigeon   NodeType = 1
	NodeType_User     NodeType = 2
	NodeType_Squirrel NodeType = 3
	NodeType_Waiter   NodeType = 4
)

var NodeType_name = map[int32]string{
	0: "Common",
	1: "Pigeon",
	2: "User",
	3: "Squirrel",
	4: "Waiter",
}

var NodeType_value = map[string]int32{
	"Common":   0,
	"Pigeon":   1,
	"User":     2,
	"Squirrel": 3,
	"Waiter":   4,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}

func (NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{3}
}

type EncryptType int32

const (
	EncryptType_AES128 EncryptType = 0
)

var EncryptType_name = map[int32]string{
	0: "AES128",
}

var EncryptType_value = map[string]int32{
	"AES128": 0,
}

func (x EncryptType) String() string {
	return proto.EnumName(EncryptType_name, int32(x))
}

func (EncryptType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{4}
}

type ErrorCode int32

const (
	ErrorCode_OK                 ErrorCode = 0
	ErrorCode_ParsingError       ErrorCode = 1
	ErrorCode_TargetAddressError ErrorCode = 2
	ErrorCode_TimeOutError       ErrorCode = 3
)

var ErrorCode_name = map[int32]string{
	0: "OK",
	1: "ParsingError",
	2: "TargetAddressError",
	3: "TimeOutError",
}

var ErrorCode_value = map[string]int32{
	"OK":                 0,
	"ParsingError":       1,
	"TargetAddressError": 2,
	"TimeOutError":       3,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}

func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{5}
}

type Frame struct {
	Type                 FrameType `protobuf:"varint,1,opt,name=Type,proto3,enum=AirNet.common.proto.FrameType" json:"Type,omitempty"`
	From                 []byte    `protobuf:"bytes,2,opt,name=From,proto3" json:"From,omitempty"`
	To                   []byte    `protobuf:"bytes,3,opt,name=To,proto3" json:"To,omitempty"`
	TTL                  int32     `protobuf:"varint,4,opt,name=TTL,proto3" json:"TTL,omitempty"`
	PassWay              []string  `protobuf:"bytes,5,rep,name=PassWay,proto3" json:"PassWay,omitempty"`
	Content              []byte    `protobuf:"bytes,6,opt,name=Content,proto3" json:"Content,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Frame) Reset()         { *m = Frame{} }
func (m *Frame) String() string { return proto.CompactTextString(m) }
func (*Frame) ProtoMessage()    {}
func (*Frame) Descriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{0}
}
func (m *Frame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Frame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Frame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Frame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Frame.Merge(m, src)
}
func (m *Frame) XXX_Size() int {
	return m.Size()
}
func (m *Frame) XXX_DiscardUnknown() {
	xxx_messageInfo_Frame.DiscardUnknown(m)
}

var xxx_messageInfo_Frame proto.InternalMessageInfo

func (m *Frame) GetType() FrameType {
	if m != nil {
		return m.Type
	}
	return FrameType_Ping
}

func (m *Frame) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Frame) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Frame) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *Frame) GetPassWay() []string {
	if m != nil {
		return m.PassWay
	}
	return nil
}

func (m *Frame) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type Pkg struct {
	Type                 PkgType         `protobuf:"varint,1,opt,name=Type,proto3,enum=AirNet.common.proto.PkgType" json:"Type,omitempty"`
	Channel              int32           `protobuf:"varint,2,opt,name=Channel,proto3" json:"Channel,omitempty"`
	No                   int32           `protobuf:"varint,3,opt,name=No,proto3" json:"No,omitempty"`
	From                 []byte          `protobuf:"bytes,4,opt,name=From,proto3" json:"From,omitempty"`
	To                   []byte          `protobuf:"bytes,5,opt,name=To,proto3" json:"To,omitempty"`
	Encryption           bool            `protobuf:"varint,6,opt,name=Encryption,proto3" json:"Encryption,omitempty"`
	Content              []byte          `protobuf:"bytes,7,opt,name=Content,proto3" json:"Content,omitempty"`
	Sign                 *SignVectorPair `protobuf:"bytes,8,opt,name=Sign,proto3" json:"Sign,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Pkg) Reset()         { *m = Pkg{} }
func (m *Pkg) String() string { return proto.CompactTextString(m) }
func (*Pkg) ProtoMessage()    {}
func (*Pkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{1}
}
func (m *Pkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pkg.Merge(m, src)
}
func (m *Pkg) XXX_Size() int {
	return m.Size()
}
func (m *Pkg) XXX_DiscardUnknown() {
	xxx_messageInfo_Pkg.DiscardUnknown(m)
}

var xxx_messageInfo_Pkg proto.InternalMessageInfo

func (m *Pkg) GetType() PkgType {
	if m != nil {
		return m.Type
	}
	return PkgType_Hello
}

func (m *Pkg) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *Pkg) GetNo() int32 {
	if m != nil {
		return m.No
	}
	return 0
}

func (m *Pkg) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Pkg) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Pkg) GetEncryption() bool {
	if m != nil {
		return m.Encryption
	}
	return false
}

func (m *Pkg) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Pkg) GetSign() *SignVectorPair {
	if m != nil {
		return m.Sign
	}
	return nil
}

type SignVectorPair struct {
	SignR                []byte   `protobuf:"bytes,1,opt,name=SignR,proto3" json:"SignR,omitempty"`
	SignS                []byte   `protobuf:"bytes,2,opt,name=SignS,proto3" json:"SignS,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignVectorPair) Reset()         { *m = SignVectorPair{} }
func (m *SignVectorPair) String() string { return proto.CompactTextString(m) }
func (*SignVectorPair) ProtoMessage()    {}
func (*SignVectorPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{2}
}
func (m *SignVectorPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignVectorPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignVectorPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignVectorPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignVectorPair.Merge(m, src)
}
func (m *SignVectorPair) XXX_Size() int {
	return m.Size()
}
func (m *SignVectorPair) XXX_DiscardUnknown() {
	xxx_messageInfo_SignVectorPair.DiscardUnknown(m)
}

var xxx_messageInfo_SignVectorPair proto.InternalMessageInfo

func (m *SignVectorPair) GetSignR() []byte {
	if m != nil {
		return m.SignR
	}
	return nil
}

func (m *SignVectorPair) GetSignS() []byte {
	if m != nil {
		return m.SignS
	}
	return nil
}

type HelloMsg struct {
	SendTime             string   `protobuf:"bytes,1,opt,name=SendTime,proto3" json:"SendTime,omitempty"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	NodeType             NodeType `protobuf:"varint,3,opt,name=NodeType,proto3,enum=AirNet.common.proto.NodeType" json:"NodeType,omitempty"`
	PublicKey            []byte   `protobuf:"bytes,4,opt,name=PublicKey,proto3" json:"PublicKey,omitempty"`
	KeyType              KeyType  `protobuf:"varint,5,opt,name=KeyType,proto3,enum=AirNet.common.proto.KeyType" json:"KeyType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HelloMsg) Reset()         { *m = HelloMsg{} }
func (m *HelloMsg) String() string { return proto.CompactTextString(m) }
func (*HelloMsg) ProtoMessage()    {}
func (*HelloMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{3}
}
func (m *HelloMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HelloMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloMsg.Merge(m, src)
}
func (m *HelloMsg) XXX_Size() int {
	return m.Size()
}
func (m *HelloMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloMsg.DiscardUnknown(m)
}

var xxx_messageInfo_HelloMsg proto.InternalMessageInfo

func (m *HelloMsg) GetSendTime() string {
	if m != nil {
		return m.SendTime
	}
	return ""
}

func (m *HelloMsg) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *HelloMsg) GetNodeType() NodeType {
	if m != nil {
		return m.NodeType
	}
	return NodeType_Common
}

func (m *HelloMsg) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *HelloMsg) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_Ecc256
}

type ExchangeMsg struct {
	Type                 EncryptType `protobuf:"varint,1,opt,name=Type,proto3,enum=AirNet.common.proto.EncryptType" json:"Type,omitempty"`
	EncryptKey           []byte      `protobuf:"bytes,2,opt,name=EncryptKey,proto3" json:"EncryptKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ExchangeMsg) Reset()         { *m = ExchangeMsg{} }
func (m *ExchangeMsg) String() string { return proto.CompactTextString(m) }
func (*ExchangeMsg) ProtoMessage()    {}
func (*ExchangeMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{4}
}
func (m *ExchangeMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeMsg.Merge(m, src)
}
func (m *ExchangeMsg) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeMsg proto.InternalMessageInfo

func (m *ExchangeMsg) GetType() EncryptType {
	if m != nil {
		return m.Type
	}
	return EncryptType_AES128
}

func (m *ExchangeMsg) GetEncryptKey() []byte {
	if m != nil {
		return m.EncryptKey
	}
	return nil
}

type QueryMsg struct {
	// Types that are valid to be assigned to Addr:
	//	*QueryMsg_Domain
	//	*QueryMsg_IP
	Addr                 isQueryMsg_Addr `protobuf_oneof:"Addr"`
	Port                 int32           `protobuf:"varint,3,opt,name=Port,proto3" json:"Port,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueryMsg) Reset()         { *m = QueryMsg{} }
func (m *QueryMsg) String() string { return proto.CompactTextString(m) }
func (*QueryMsg) ProtoMessage()    {}
func (*QueryMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_92312855cad1e50f, []int{5}
}
func (m *QueryMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryMsg.Merge(m, src)
}
func (m *QueryMsg) XXX_Size() int {
	return m.Size()
}
func (m *QueryMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryMsg.DiscardUnknown(m)
}

var xxx_messageInfo_QueryMsg proto.InternalMessageInfo

type isQueryMsg_Addr interface {
	isQueryMsg_Addr()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryMsg_Domain struct {
	Domain string `protobuf:"bytes,1,opt,name=Domain,proto3,oneof"`
}
type QueryMsg_IP struct {
	IP []byte `protobuf:"bytes,2,opt,name=IP,proto3,oneof"`
}

func (*QueryMsg_Domain) isQueryMsg_Addr() {}
func (*QueryMsg_IP) isQueryMsg_Addr()     {}

func (m *QueryMsg) GetAddr() isQueryMsg_Addr {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *QueryMsg) GetDomain() string {
	if x, ok := m.GetAddr().(*QueryMsg_Domain); ok {
		return x.Domain
	}
	return ""
}

func (m *QueryMsg) GetIP() []byte {
	if x, ok := m.GetAddr().(*QueryMsg_IP); ok {
		return x.IP
	}
	return nil
}

func (m *QueryMsg) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*QueryMsg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _QueryMsg_OneofMarshaler, _QueryMsg_OneofUnmarshaler, _QueryMsg_OneofSizer, []interface{}{
		(*QueryMsg_Domain)(nil),
		(*QueryMsg_IP)(nil),
	}
}

func _QueryMsg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*QueryMsg)
	// Addr
	switch x := m.Addr.(type) {
	case *QueryMsg_Domain:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Domain)
	case *QueryMsg_IP:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.IP)
	case nil:
	default:
		return fmt.Errorf("QueryMsg.Addr has unexpected type %T", x)
	}
	return nil
}

func _QueryMsg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*QueryMsg)
	switch tag {
	case 1: // Addr.Domain
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Addr = &QueryMsg_Domain{x}
		return true, err
	case 2: // Addr.IP
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Addr = &QueryMsg_IP{x}
		return true, err
	default:
		return false, nil
	}
}

func _QueryMsg_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*QueryMsg)
	// Addr
	switch x := m.Addr.(type) {
	case *QueryMsg_Domain:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Domain)))
		n += len(x.Domain)
	case *QueryMsg_IP:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.IP)))
		n += len(x.IP)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterEnum("AirNet.common.proto.FrameType", FrameType_name, FrameType_value)
	proto.RegisterEnum("AirNet.common.proto.PkgType", PkgType_name, PkgType_value)
	proto.RegisterEnum("AirNet.common.proto.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("AirNet.common.proto.NodeType", NodeType_name, NodeType_value)
	proto.RegisterEnum("AirNet.common.proto.EncryptType", EncryptType_name, EncryptType_value)
	proto.RegisterEnum("AirNet.common.proto.ErrorCode", ErrorCode_name, ErrorCode_value)
	proto.RegisterType((*Frame)(nil), "AirNet.common.proto.Frame")
	proto.RegisterType((*Pkg)(nil), "AirNet.common.proto.Pkg")
	proto.RegisterType((*SignVectorPair)(nil), "AirNet.common.proto.SignVectorPair")
	proto.RegisterType((*HelloMsg)(nil), "AirNet.common.proto.HelloMsg")
	proto.RegisterType((*ExchangeMsg)(nil), "AirNet.common.proto.ExchangeMsg")
	proto.RegisterType((*QueryMsg)(nil), "AirNet.common.proto.QueryMsg")
}

func init() { proto.RegisterFile("agreement.proto", fileDescriptor_92312855cad1e50f) }

var fileDescriptor_92312855cad1e50f = []byte{
	// 693 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x53, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xcd, 0x38, 0x76, 0xe2, 0xdc, 0x44, 0xf9, 0x46, 0xf3, 0x21, 0x30, 0xa8, 0x44, 0x21, 0x6c,
	0xa2, 0x48, 0x44, 0x34, 0xfd, 0xa1, 0x95, 0xd8, 0xb4, 0x25, 0x55, 0xab, 0x42, 0x6a, 0x26, 0x81,
	0x4a, 0xec, 0x5c, 0x67, 0xe4, 0x5a, 0x8d, 0x67, 0xca, 0xd8, 0x11, 0xe4, 0x4d, 0x78, 0x01, 0xde,
	0x85, 0x25, 0x5b, 0x76, 0xa8, 0xbc, 0x04, 0x4b, 0x34, 0x63, 0x3b, 0x75, 0x44, 0xc4, 0x2a, 0x73,
	0xcf, 0x9c, 0xb9, 0x39, 0xe7, 0xdc, 0x6b, 0xf8, 0xcf, 0x0b, 0x24, 0x63, 0x11, 0xe3, 0x49, 0xff,
	0x46, 0x8a, 0x44, 0x90, 0xff, 0x0f, 0x42, 0x39, 0x62, 0x49, 0xdf, 0x17, 0x51, 0x24, 0x78, 0x0a,
	0x76, 0xbe, 0x22, 0xb0, 0x8e, 0xa5, 0x17, 0x31, 0x32, 0x00, 0x73, 0xb2, 0xb8, 0x61, 0x0e, 0x6a,
	0xa3, 0x6e, 0x73, 0xd0, 0xea, 0xaf, 0x61, 0xf7, 0x35, 0x53, 0xb1, 0xa8, 0xe6, 0x12, 0x02, 0xe6,
	0xb1, 0x14, 0x91, 0x63, 0xb4, 0x51, 0xb7, 0x41, 0xf5, 0x99, 0x34, 0xc1, 0x98, 0x08, 0xa7, 0xac,
	0x11, 0x63, 0x22, 0x08, 0x86, 0xf2, 0x64, 0xf2, 0xda, 0x31, 0xdb, 0xa8, 0x6b, 0x51, 0x75, 0x24,
	0x0e, 0x54, 0x5d, 0x2f, 0x8e, 0x2f, 0xbc, 0x85, 0x63, 0xb5, 0xcb, 0xdd, 0x1a, 0xcd, 0x4b, 0x75,
	0x73, 0x24, 0x78, 0xc2, 0x78, 0xe2, 0x54, 0x74, 0x83, 0xbc, 0xec, 0xfc, 0x46, 0x50, 0x76, 0xaf,
	0x03, 0xf2, 0x7c, 0x45, 0xe5, 0xc6, 0x5a, 0x95, 0xee, 0x75, 0x50, 0xd0, 0xa8, 0x7a, 0x5e, 0x79,
	0x9c, 0xb3, 0x99, 0x96, 0x69, 0xd1, 0xbc, 0x54, 0x4a, 0x47, 0xa9, 0x52, 0x8b, 0x1a, 0x23, 0xb1,
	0x74, 0x63, 0xfe, 0xe5, 0xc6, 0x5a, 0xba, 0x69, 0x01, 0x0c, 0xb9, 0x2f, 0x17, 0x37, 0x49, 0x28,
	0xb8, 0x16, 0x69, 0xd3, 0x02, 0x52, 0x74, 0x50, 0x5d, 0x71, 0x40, 0x5e, 0x80, 0x39, 0x0e, 0x03,
	0xee, 0xd8, 0x6d, 0xd4, 0xad, 0x0f, 0x9e, 0xae, 0x55, 0xae, 0x08, 0xef, 0x99, 0x9f, 0x08, 0xe9,
	0x7a, 0xa1, 0xa4, 0xfa, 0x41, 0xe7, 0x25, 0x34, 0x57, 0x71, 0x72, 0x0f, 0x2c, 0x85, 0x50, 0x9d,
	0x42, 0x83, 0xa6, 0x45, 0x8e, 0x8e, 0xb3, 0x69, 0xa4, 0x45, 0xe7, 0x07, 0x02, 0xfb, 0x84, 0xcd,
	0x66, 0xe2, 0x4d, 0x1c, 0x90, 0x47, 0x60, 0x8f, 0x19, 0x9f, 0x4e, 0xc2, 0x28, 0x4d, 0xb0, 0x46,
	0x97, 0x35, 0x69, 0x43, 0x7d, 0xca, 0x62, 0x5f, 0x86, 0xa9, 0x35, 0x43, 0x5f, 0x17, 0x21, 0xb2,
	0x0f, 0xf6, 0x48, 0x4c, 0xf5, 0xfc, 0x75, 0x6a, 0xcd, 0xc1, 0xe3, 0xb5, 0x2e, 0x72, 0x12, 0x5d,
	0xd2, 0xc9, 0x06, 0xd4, 0xdc, 0xf9, 0xe5, 0x2c, 0xf4, 0xcf, 0xd8, 0x22, 0xcb, 0xf7, 0x0e, 0x20,
	0xbb, 0x50, 0x3d, 0x63, 0x0b, 0xdd, 0xd7, 0xfa, 0xc7, 0x5c, 0x33, 0x0e, 0xcd, 0xc9, 0x1d, 0x1f,
	0xea, 0xc3, 0xcf, 0xfe, 0x95, 0xc7, 0x03, 0xa6, 0xdc, 0x6d, 0xaf, 0xec, 0x46, 0x7b, 0x6d, 0x8f,
	0x6c, 0x54, 0x85, 0xfd, 0xb8, 0x9b, 0xa8, 0xd2, 0x96, 0x66, 0x57, 0x40, 0x3a, 0x14, 0xec, 0xb7,
	0x73, 0x26, 0x17, 0xea, 0x1f, 0x1c, 0xa8, 0xbc, 0x12, 0x91, 0x17, 0xf2, 0x34, 0xbd, 0x93, 0x12,
	0xcd, 0x6a, 0x82, 0xc1, 0x38, 0x75, 0xd3, 0xd7, 0x27, 0x25, 0x6a, 0x9c, 0xba, 0x6a, 0x9b, 0x5c,
	0x21, 0x93, 0x6c, 0xbf, 0xf4, 0xf9, 0xb0, 0x02, 0xe6, 0xc1, 0x74, 0x2a, 0x7b, 0x4f, 0xa0, 0xb6,
	0xfc, 0x94, 0x88, 0x0d, 0xa6, 0x1b, 0xf2, 0x00, 0x97, 0x08, 0x40, 0x65, 0x24, 0x64, 0xe4, 0xcd,
	0x30, 0xea, 0xed, 0x43, 0x35, 0xdb, 0x63, 0x52, 0x03, 0x4b, 0x4f, 0x10, 0x97, 0x48, 0x03, 0xec,
	0xdc, 0x31, 0x46, 0xea, 0x42, 0x4b, 0xc3, 0x86, 0x7a, 0x7a, 0xc0, 0xe3, 0x4f, 0x4c, 0xe2, 0x72,
	0xef, 0xd9, 0x32, 0x4e, 0x05, 0x0f, 0x7d, 0x7f, 0xb0, 0xb3, 0x9b, 0x76, 0x1f, 0xfa, 0xfe, 0xd6,
	0xde, 0x36, 0x46, 0xd9, 0x79, 0x67, 0x73, 0x80, 0x8d, 0xde, 0xf1, 0xdd, 0x58, 0x15, 0x7e, 0xa4,
	0xe3, 0x4a, 0xf9, 0x6e, 0x18, 0x30, 0xc1, 0x31, 0x52, 0x1a, 0xdf, 0xc5, 0x4c, 0x62, 0x43, 0x29,
	0x18, 0x7f, 0x9c, 0x87, 0x52, 0xb2, 0x19, 0x2e, 0x2b, 0xce, 0x85, 0x17, 0x26, 0x4c, 0x62, 0xb3,
	0xf7, 0x10, 0xea, 0x85, 0x74, 0xb5, 0xa2, 0xe1, 0x78, 0x73, 0xb0, 0x87, 0x4b, 0xbd, 0x73, 0xa8,
	0x0d, 0xa5, 0x14, 0xf2, 0x48, 0x4c, 0x19, 0xa9, 0x80, 0x71, 0x7e, 0x86, 0x4b, 0x04, 0x43, 0xc3,
	0xf5, 0x64, 0x1c, 0xf2, 0x40, 0xdf, 0x61, 0x44, 0xee, 0x03, 0x99, 0x78, 0x32, 0x60, 0x89, 0x0a,
	0x89, 0xc5, 0x71, 0x8a, 0x1b, 0x8a, 0xa9, 0x56, 0xf4, 0x7c, 0x9e, 0xa4, 0x48, 0xf9, 0xf0, 0xc1,
	0xb7, 0xdb, 0x16, 0xfa, 0x7e, 0xdb, 0x42, 0x3f, 0x6f, 0x5b, 0xe8, 0xcb, 0xaf, 0x56, 0xe9, 0x83,
	0xa5, 0xe7, 0x7b, 0x59, 0xd1, 0x3f, 0x5b, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xb2, 0x8e, 0xc9,
	0x11, 0xfe, 0x04, 0x00, 0x00,
}

func (m *Frame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Frame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.Type))
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.TTL != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.TTL))
	}
	if len(m.PassWay) > 0 {
		for _, s := range m.PassWay {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Pkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pkg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.Type))
	}
	if m.Channel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.Channel))
	}
	if m.No != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.No))
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.Encryption {
		dAtA[i] = 0x30
		i++
		if m.Encryption {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Sign != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.Sign.Size()))
		n1, err := m.Sign.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SignVectorPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignVectorPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SignR) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.SignR)))
		i += copy(dAtA[i:], m.SignR)
	}
	if len(m.SignS) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.SignS)))
		i += copy(dAtA[i:], m.SignS)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HelloMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SendTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.SendTime)))
		i += copy(dAtA[i:], m.SendTime)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.NodeType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.NodeType))
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.KeyType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.KeyType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExchangeMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.Type))
	}
	if len(m.EncryptKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.EncryptKey)))
		i += copy(dAtA[i:], m.EncryptKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueryMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Addr != nil {
		nn2, err := m.Addr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueryMsg_Domain) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintAgreement(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	return i, nil
}
func (m *QueryMsg_IP) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IP != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAgreement(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	return i, nil
}
func encodeVarintAgreement(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Frame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgreement(uint64(m.Type))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovAgreement(uint64(m.TTL))
	}
	if len(m.PassWay) > 0 {
		for _, s := range m.PassWay {
			l = len(s)
			n += 1 + l + sovAgreement(uint64(l))
		}
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgreement(uint64(m.Type))
	}
	if m.Channel != 0 {
		n += 1 + sovAgreement(uint64(m.Channel))
	}
	if m.No != 0 {
		n += 1 + sovAgreement(uint64(m.No))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.Encryption {
		n += 2
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.Sign != nil {
		l = m.Sign.Size()
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SignVectorPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SignR)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	l = len(m.SignS)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HelloMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SendTime)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.NodeType != 0 {
		n += 1 + sovAgreement(uint64(m.NodeType))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovAgreement(uint64(m.KeyType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgreement(uint64(m.Type))
	}
	l = len(m.EncryptKey)
	if l > 0 {
		n += 1 + l + sovAgreement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Addr != nil {
		n += m.Addr.Size()
	}
	if m.Port != 0 {
		n += 1 + sovAgreement(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryMsg_Domain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	n += 1 + l + sovAgreement(uint64(l))
	return n
}
func (m *QueryMsg_IP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IP != nil {
		l = len(m.IP)
		n += 1 + l + sovAgreement(uint64(l))
	}
	return n
}

func sovAgreement(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAgreement(x uint64) (n int) {
	return sovAgreement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Frame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgreement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Frame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Frame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FrameType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassWay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PassWay = append(m.PassWay, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgreement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgreement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PkgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field No", wireType)
			}
			m.No = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.No |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Encryption = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sign == nil {
				m.Sign = &SignVectorPair{}
			}
			if err := m.Sign.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgreement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignVectorPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgreement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignVectorPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignVectorPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignR = append(m.SignR[:0], dAtA[iNdEx:postIndex]...)
			if m.SignR == nil {
				m.SignR = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignS = append(m.SignS[:0], dAtA[iNdEx:postIndex]...)
			if m.SignS == nil {
				m.SignS = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgreement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelloMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgreement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SendTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= KeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgreement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgreement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EncryptType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptKey = append(m.EncryptKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptKey == nil {
				m.EncryptKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgreement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgreement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = &QueryMsg_Domain{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgreement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAgreement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Addr = &QueryMsg_IP{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgreement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAgreement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgreement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgreement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgreement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAgreement
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAgreement
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAgreement
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAgreement(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAgreement
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAgreement = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgreement   = fmt.Errorf("proto: integer overflow")
)
